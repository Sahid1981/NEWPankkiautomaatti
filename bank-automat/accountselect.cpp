/* This is an account selection dialog that is displayed after login if the user has multiple accounts (debit/credit). It:
- receives information from the login
- displays the user's name
- displays only the buttons (Debit/Credit) that the user actually has
- opens the actual account window based on the selection
- draws the background image manually */ 

#include "accountselect.h"
#include "account.h"
#include "avatar.h"
#include "ui_accountselect.h"
#include <QPainter>
#include <QPixmap>
#include <QPushButton>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>
#include <algorithm>

// accountselect is a modal dialog shown after login, allowing the user to choose between Debit and Credit accounts
accountselect::accountselect(
    const LoginResultDto& loginResult,  // Data returned from successful login
    ApiClient* api,                     // API client (shared with other windows)
    QTimer* inactivityTimer,            // Global inactivity timer to prevent timeout
    QWidget *parent
)
: QDialog(parent)
, ui(new Ui::accountselect)
, m_api(api)
, m_login(loginResult)
, m_inactivityTimer(inactivityTimer)
{
    // Initialize UI elements generated by Qt Designer
    ui->setupUi(this);
    
    // Display the logged-in user's identifier
    ui->labelTest->setText("Käyttäjä: " + m_login.fName);

    m_avatarPreview = new QLabel(ui->card);
    m_avatarPreview->setFixedSize(96, 96);
    m_avatarPreview->setAlignment(Qt::AlignCenter);
    m_avatarPreview->setStyleSheet("background:#ffffff; border:2px solid #c0c0c0; border-radius:8px;");
    QPixmap ph(92, 92);
    ph.fill(QColor("#e9e9e9"));
    m_avatarPreview->setPixmap(ph.scaled(m_avatarPreview->size(), Qt::KeepAspectRatio, Qt::SmoothTransformation));
    
    // Initialize network manager for loading avatars
    m_avatarNam = new QNetworkAccessManager(this);

    // Load avatar from login result if available
    if (!m_login.avatarUrl.isEmpty()) {
        loadAvatarFromUrl(m_login.avatarUrl);
    }
    
    // Build a map from account type ("debit"/"credit") to account ID
    for (const AccountDto& acc : m_login.accounts) {
        accountIdByType[acc.type.toLower()] = acc.idAccount;
    }
    
    // Check which account types the user has
    const bool hasDebit  = accountIdByType.contains("debit");
    const bool hasCredit = accountIdByType.contains("credit");
    QString hasAdmin = loginResult.role;
    
    // Show only the buttons that correspond to existing accounts
    ui->btnSelectDebit->setVisible(hasDebit);
    ui->btnSelectCredit->setVisible(hasCredit);
    
    // Add optional Edit Avatar button
    m_btnEditAvatar = new QPushButton(""Vaihda \n profiilikuva"", ui->card);
    m_btnEditAvatar->setFixedSize(120, 36);
    m_btnEditAvatar->setStyleSheet(
        "background-color: #4CAF50; color: white; border: none; border-radius: 5px; font-weight: bold;"
    );
    connect(m_btnEditAvatar, &QPushButton::clicked, this, &accountselect::openAvatarDialog);

    layoutHeaderControls();
    
    // Network manager already initialized above
}

// Destructor: clean up UI
accountselect::~accountselect()
{
    delete ui;
}

// Called automatically when the Debit button is clicked
void accountselect::on_btnSelectDebit_clicked()
{
    selectedAccountType = "debit";
    openAccountWindow();
}

// Called automatically when the Credit button is clicked
void accountselect::on_btnSelectCredit_clicked()
{
    selectedAccountType = "credit";
    openAccountWindow();
}

// Called when the Edit Avatar button is clicked - opens avatar selection dialog
void accountselect::openAvatarDialog()
{
    if (!avatarDialog) {
        avatarDialog = new avatar(m_login, m_api, m_inactivityTimer, this);
        avatarDialog->setAttribute(Qt::WA_DeleteOnClose);
        connect(avatarDialog, &avatar::avatarApplied, this, [this](const QPixmap& pixmap, const QString&) {
            setAvatarPreview(pixmap);
        });
    }
    // Show the avatar dialog as a modeless dialog (not blocking the account selection)
    avatarDialog->show();
    avatarDialog->raise();
    avatarDialog->activateWindow();
}

// Called automatically when the Admin button is clicked
// void accountselect::on_btnSelectAdmin_clicked()
// {
//     openAdminWindow();
// }

// Opens the main account window based on the selected account type
void accountselect::openAccountWindow()
{
    if (m_btnEditAvatar) {
        m_btnEditAvatar->hide();
    }

    // Resolve account ID from the selected type
    const int idAccount = accountIdByType.value(selectedAccountType, -1);
    if (idAccount < 0) return;

    // Create the account window
    account* accountWindow = new account(
        idAccount,
        m_login.idUser,
        m_login.fName,
        m_api,
        m_avatarPixmap,
        nullptr
    );
    
    // Automatically delete the window object when it is closed
    accountWindow->setAttribute(Qt::WA_DeleteOnClose);
    // Show the account window in full screen
    accountWindow->showMaximized();
    // Close this account selection dialog
    close();
}

void accountselect::setAvatarPreview(const QPixmap& pixmap)
{
    if (pixmap.isNull() || !m_avatarPreview) return;
    m_avatarPixmap = pixmap;
    m_avatarPreview->setPixmap(pixmap.scaled(m_avatarPreview->size(), Qt::KeepAspectRatio, Qt::SmoothTransformation));
}

// Custom paint event to draw a background image for the dialog
void accountselect::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    // Load background image from Qt resource system
    QPixmap bg(":/images/background.png");
    // Scale and draw the image to fill the entire dialog
    painter.drawPixmap(rect(), bg);
}

void accountselect::resizeEvent(QResizeEvent *event)
{
    QDialog::resizeEvent(event);
    layoutHeaderControls();
    if (m_avatarPreview && !m_avatarPixmap.isNull()) {
        m_avatarPreview->setPixmap(m_avatarPixmap.scaled(m_avatarPreview->size(), Qt::KeepAspectRatio, Qt::SmoothTransformation));
    }
}

void accountselect::layoutHeaderControls()
{
    if (!ui || !ui->titleLabel) return;

    const QRect titleRect = ui->titleLabel->geometry();
    const int gap = 12;
    const int edgeMargin = 30;
    const int cardMidY = ui->card->height() / 2;

    if (m_avatarPreview) {
        const int wantedAvatarX = titleRect.left() - gap - m_avatarPreview->width();
        const int maxAvatarX = std::max(edgeMargin, ui->card->width() - m_avatarPreview->width() - edgeMargin);
        const int avatarX = std::clamp(wantedAvatarX, edgeMargin, maxAvatarX);
        const int maxAvatarY = std::max(0, ui->card->height() - m_avatarPreview->height());
         const int avatarY = std::clamp(cardMidY - (m_avatarPreview->height() / 2), 0, maxAvatarY);
        m_avatarPreview->move(avatarX, avatarY);
    }

    if (m_btnEditAvatar) {
        const int maxX = std::max(edgeMargin, ui->card->width() - m_btnEditAvatar->width() - edgeMargin);
        const int wantedX = titleRect.right() + gap;
        const int buttonX = std::clamp(wantedX, edgeMargin, maxX);
        const int maxButtonY = std::max(0, ui->card->height() - m_btnEditAvatar->height());
        const int buttonY = std::clamp(cardMidY - (m_btnEditAvatar->height() / 2) - 5, 0, maxButtonY);
        m_btnEditAvatar->move(buttonX, buttonY);
    }
}

void accountselect::loadAvatarFromUrl(const QString& url)
{
    if (url.isEmpty() || !m_avatarNam) return;
    
    QUrl resolvedUrl(url);
    if (!resolvedUrl.isValid() || resolvedUrl.isRelative()) {
        if (m_api) {
            resolvedUrl = m_api->baseUrl().resolved(QUrl(url));
        }
    }
    
    if (!resolvedUrl.scheme().startsWith("http")) return;
    
    QNetworkReply* reply = m_avatarNam->get(QNetworkRequest(resolvedUrl));
    connect(reply, &QNetworkReply::finished, this, [this, reply]() {
        const QByteArray bytes = reply->readAll();
        QPixmap pixmap;
        const bool loaded = pixmap.loadFromData(bytes);
        reply->deleteLater();
        
        if (loaded && !pixmap.isNull()) {
            setAvatarPreview(pixmap);
        }
    });
}



